import asyncio
import json
import os
from datetime import datetime
from aiogram import Bot, Dispatcher, types
from aiogram.types import LabeledPrice, PreCheckoutQuery
from aiogram.contrib.fsm_storage.memory import MemoryStorage
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup
from aiogram.utils.callback_data import CallbackData

# ================== –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã ==================
API_TOKEN = "8423035573:AAHo53sPuZJXbGXLhW5-EThbdXM5GrCULDQ"
BOT_USERNAME = "cat777_cash_bot"
GROUP_ID = -1002522022019
ADMIN_ID = 827299190
PROVIDER_TOKEN = "390540012:LIVE:77400"  # –¢–æ–∫–µ–Ω –º–∞–≥–∞–∑–∏–Ω–∞ –∏–∑ BotFather
USERS_FILE = "users_data.json"

TARIFFS = {
    "free": {"price": 0, "posts_per_day": 1},
    "pro": {"price": 200, "posts_per_day": 3},
    "premium": {"price": 1000, "posts_per_day": 15}
}

# ================== –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ ==================
if os.path.exists(USERS_FILE):
    with open(USERS_FILE, "r", encoding="utf-8") as f:
        users_data = json.load(f)
else:
    users_data = {}

users_data[str(ADMIN_ID)] = {"tariff": "premium", "posts_today": 0, "last_post_day": None, "history": [], "email": None}

def save_users_data():
    with open(USERS_FILE, "w", encoding="utf-8") as f:
        json.dump(users_data, f, ensure_ascii=False, indent=2)

# ================== FSM ==================
class PostStates(StatesGroup):
    waiting_for_post = State()
    waiting_for_email = State()

# ================== CallbackData ==================
tariff_cb = CallbackData("tariff", "name")

# ================== –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ==================
bot = Bot(token=API_TOKEN, parse_mode=types.ParseMode.HTML)
storage = MemoryStorage()
dp = Dispatcher(bot, storage=storage)

# ================== –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é ==================
def main_menu():
    keyboard = types.InlineKeyboardMarkup(row_width=1)
    keyboard.add(
        types.InlineKeyboardButton("üì¢ –°–æ–∑–¥–∞—Ç—å –ø–æ—Å—Ç", callback_data="create_post"),
        types.InlineKeyboardButton("üí≥ –°–º–µ–Ω–∏—Ç—å —Ç–∞—Ä–∏—Ñ", callback_data="change_tariff"),
        types.InlineKeyboardButton("üìú –ú–æ–∏ –ø–æ—Å—Ç—ã", callback_data="my_posts")
    )
    return keyboard

# ================== /start ==================
@dp.message_handler(commands=["start"])
async def start_handler(message: types.Message):
    if message.chat.type != "private":
        await message.reply(f"–ü—É–±–ª–∏–∫–∞—Ü–∏—è –ø–æ—Å—Ç–æ–≤ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤ –ª–∏—á–∫–µ.\n–ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ –ª–∏—á–∫—É: @{BOT_USERNAME}")
        return
    user_id = str(message.from_user.id)
    if user_id not in users_data:
        users_data[user_id] = {"tariff": "free", "posts_today": 0, "last_post_day": None, "history": [], "email": None}
        save_users_data()
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=main_menu())

# ================== –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–æ–∫ ==================
@dp.callback_query_handler(lambda c: True)
async def menu_handler(callback_query: types.CallbackQuery):
    user_id = str(callback_query.from_user.id)

    if user_id not in users_data:
        users_data[user_id] = {"tariff": "free", "posts_today": 0, "last_post_day": None, "history": [], "email": None}

    user = users_data[user_id]
    data = callback_query.data

    if data == "create_post":
        today = datetime.now().day
        if user["last_post_day"] != today:
            user["posts_today"] = 0
            user["last_post_day"] = today
            save_users_data()
        tariff_info = TARIFFS[user["tariff"]]
        if user["posts_today"] >= tariff_info["posts_per_day"]:
            await show_tariff_buttons(callback_query, user)
            return
        await callback_query.message.answer("–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç, —Ñ–æ—Ç–æ –∏–ª–∏ –≤–∏–¥–µ–æ –¥–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏.")
        await PostStates.waiting_for_post.set()

    elif data == "change_tariff":
        await show_tariff_buttons(callback_query, user)

    elif data.startswith("pay_"):
        tariff = data[4:]
        await process_payment(callback_query, user, tariff)

    elif data == "my_posts":
        hist = user["history"]
        if not hist:
            await callback_query.message.edit_text("–ò—Å—Ç–æ—Ä–∏—è –ø–æ–∫–∞ –ø—É—Å—Ç–∞.", reply_markup=main_menu())
            return
        for idx, post in enumerate(hist):
            post_preview = post.get("text") if post["type"]=="text" else f"[{post['type'].capitalize()}] {post.get('caption','')}"
            keyboard = types.InlineKeyboardMarkup(row_width=2)
            keyboard.add(
                types.InlineKeyboardButton(f"üîÅ –û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å #{idx+1}", callback_data=f"repost_{idx}"),
                types.InlineKeyboardButton(f"‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å", callback_data=f"edit_{idx}")
            )
            await callback_query.message.answer(f"{idx+1}. {post_preview}", reply_markup=keyboard)

# ================== –ö–Ω–æ–ø–∫–∏ —Ç–∞—Ä–∏—Ñ–∞ ==================
async def show_tariff_buttons(callback_query, user):
    keyboard = types.InlineKeyboardMarkup(row_width=1)
    for name, info in TARIFFS.items():
        if name == "free":
            continue
        keyboard.add(types.InlineKeyboardButton(f"{name.capitalize()} {info['price']} ‚ÇΩ / {info['posts_per_day']} –ø–æ—Å—Ç–æ–≤ –≤ –¥–µ–Ω—å", callback_data=f"pay_{name}"))
    await callback_query.message.answer(f"–í–∞—à —Ç–µ–∫—É—â–∏–π —Ç–∞—Ä–∏—Ñ: {user['tariff']}", reply_markup=keyboard)
    return keyboard

# ================== –û–ø–ª–∞—Ç–∞ —Ç–∞—Ä–∏—Ñ–∞ ==================
async def process_payment(callback_query, user, tariff):
    info = TARIFFS[tariff]
    price = info["price"]
    await bot.send_invoice(
        callback_query.from_user.id,
        title=f"{tariff.capitalize()} —Ç–∞—Ä–∏—Ñ",
        description=f"–û–ø–ª–∞—Ç–∞ —Ç–∞—Ä–∏—Ñ–∞ {tariff.capitalize()}",
        payload=tariff,
        provider_token=PROVIDER_TOKEN,
        currency="RUB",
        prices=[LabeledPrice(label=f"{tariff.capitalize()} —Ç–∞—Ä–∏—Ñ", amount=price*100)],
        need_email=True,
        send_email_to_provider=True
    )

# ================== PreCheckout ==================
@dp.pre_checkout_query_handler(lambda query: True)
async def pre_checkout(pre_checkout_q: PreCheckoutQuery):
    await bot.answer_pre_checkout_query(pre_checkout_q.id, ok=True)

# ================== –£—Å–ø–µ—à–Ω—ã–π –ø–ª–∞—Ç–µ–∂ ==================
@dp.message_handler(content_types=types.ContentType.SUCCESSFUL_PAYMENT)
async def successful_payment(message: types.Message):
    tariff = message.successful_payment.invoice_payload
    user_id = str(message.from_user.id)
    users_data[user_id]["tariff"] = tariff
    save_users_data()
    await message.answer(f"–û–ø–ª–∞—Ç–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ! –¢–∞—Ä–∏—Ñ {tariff} –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω.", reply_markup=main_menu())

# ================== –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ—Å—Ç–∞ ==================
@dp.message_handler(state=PostStates.waiting_for_post, content_types=types.ContentTypes.ANY)
async def handle_post(message: types.Message, state: FSMContext):
    user_id = str(message.from_user.id)
    content_type = message.content_type
    post = {"type": content_type, "text": message.text, "caption": getattr(message, 'caption', None)}
    users_data[user_id]["history"].append(post)
    users_data[user_id]["posts_today"] += 1
    save_users_data()
    await state.finish()
    await message.answer("–ü–æ—Å—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω –∏ –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω (—Å–∏–º—É–ª—è—Ü–∏—è).", reply_markup=main_menu())

# ================== –ó–∞–ø—É—Å–∫ ==================
if __name__ == "__main__":
    from aiogram import executor
    executor.start_polling(dp, skip_updates=True)
